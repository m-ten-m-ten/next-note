{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport fs from \"fs\";\nimport path from \"path\";\nimport matter from \"gray-matter\";\nimport remark from \"remark\";\nimport html from \"remark-html\";\nconst postsDirectory = path.join(process.cwd(), \"posts\");\nexport function getSortedPostsData() {\n  // /posts 配下のファイル名を取得する。\n  const fileNames = fs.readdirSync(postsDirectory);\n  const allPostData = [];\n  fileNames.forEach(fileName => {\n    if (fileName.charAt(0) !== '.' && fileName.charAt(0) !== '_') {\n      // slugを取得するためにファイル名から\".md\"を削除する。\n      const slug = fileName.replace(/\\.md$/, \"\"); // マークダウンファイルを文字列として読み取る。\n\n      const fullPath = path.join(postsDirectory, fileName);\n      const fileContents = fs.readFileSync(fullPath, \"utf8\"); // 投稿のメタデータ部分を解析するためにgray-matterを使う。\n\n      const matterResult = matter(fileContents); // データをslugと合わせる。\n\n      allPostData.push(_objectSpread({\n        slug\n      }, matterResult.data));\n    }\n  });\n  return allPostData.sort((a, b) => {\n    if (a.pub_date < b.pub_date) {\n      return 1;\n    } else {\n      return -1;\n    }\n  });\n}\nexport function getAllPostSlugs() {\n  const fileNames = fs.readdirSync(postsDirectory);\n  return fileNames.map(fileName => {\n    return {\n      params: {\n        slug: fileName.replace(/\\.md$/, \"\")\n      }\n    };\n  });\n}\nexport async function getPostData(slug) {\n  const fullPath = path.join(postsDirectory, `${slug}.md`);\n  const fileContents = fs.readFileSync(fullPath, \"utf8\");\n  const matterResult = matter(fileContents);\n  const processedContent = await remark().use(html).process(matterResult.content);\n  const contentHtml = processedContent.toString();\n  return _objectSpread({\n    slug,\n    contentHtml\n  }, matterResult.data);\n}\nexport function getCategories() {\n  const allPostData = getSortedPostsData();\n  const categories = [];\n  allPostData.forEach(post => {\n    if (post.category && !categories.includes(post.category)) {\n      categories.push(post.category);\n    }\n  });\n  return categories;\n}\nexport function getCategoryPaths() {\n  const categories = getCategories();\n  return categories.map(category => {\n    return {\n      params: {\n        category\n      }\n    };\n  });\n}\nexport function getSortedCategoryPostsData(category) {\n  const allPostData = getSortedPostsData();\n  const categoryPostsData = [];\n  allPostData.forEach(post => {\n    if (post.category === category) {\n      categoryPostsData.push(post);\n    }\n  });\n  return categoryPostsData;\n}\nexport function getTags() {\n  const allPostData = getSortedPostsData();\n  const tags = [];\n  allPostData.forEach(post => {\n    if (post.tags) {\n      post.tags.forEach(tag => {\n        if (!tags.includes(tag)) {\n          tags.push(tag);\n        }\n      });\n    }\n  });\n  return tags;\n}\nexport function getTagPaths() {\n  const tags = getTags();\n  return tags.map(tag => {\n    return {\n      params: {\n        tag\n      }\n    };\n  });\n}\nexport function getSortedTagPostsData(tag) {\n  const allPostData = getSortedPostsData();\n  const tagPostsData = [];\n  allPostData.forEach(post => {\n    if (post.tags && post.tags.includes(tag)) {\n      tagPostsData.push(post);\n    }\n  });\n  return tagPostsData;\n}","map":{"version":3,"sources":["/Users/matsuotenmei/program/NextJs/next-note/src/lib/posts.ts"],"names":["fs","path","matter","remark","html","postsDirectory","join","process","cwd","getSortedPostsData","fileNames","readdirSync","allPostData","forEach","fileName","charAt","slug","replace","fullPath","fileContents","readFileSync","matterResult","push","data","sort","a","b","pub_date","getAllPostSlugs","map","params","getPostData","processedContent","use","content","contentHtml","toString","getCategories","categories","post","category","includes","getCategoryPaths","getSortedCategoryPostsData","categoryPostsData","getTags","tags","tag","getTagPaths","getSortedTagPostsData","tagPostsData"],"mappings":"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","sourcesContent":["import fs from \"fs\";\nimport path from \"path\";\nimport matter from \"gray-matter\";\nimport remark from \"remark\";\nimport html from \"remark-html\";\n\nconst postsDirectory = path.join(process.cwd(), \"posts\");\n\nexport function getSortedPostsData() {\n  // /posts 配下のファイル名を取得する。\n  const fileNames = fs.readdirSync(postsDirectory);\n\n  const allPostData = [];\n  \n  fileNames.forEach((fileName) => {\n    if (fileName.charAt(0) !== '.' && fileName.charAt(0) !== '_') {\n      // slugを取得するためにファイル名から\".md\"を削除する。\n      const slug = fileName.replace(/\\.md$/, \"\");\n\n      // マークダウンファイルを文字列として読み取る。\n      const fullPath = path.join(postsDirectory, fileName);\n      const fileContents = fs.readFileSync(fullPath, \"utf8\");\n\n      // 投稿のメタデータ部分を解析するためにgray-matterを使う。\n      const matterResult = matter(fileContents);\n\n      // データをslugと合わせる。\n      allPostData.push({\n        slug,\n        ...matterResult.data,\n      });\n    }\n  });\n\n  return allPostData.sort((a, b) => {\n    if (a.pub_date < b.pub_date) {\n      return 1;\n    } else {\n      return -1;\n    }\n  });\n}\n\nexport function getAllPostSlugs() {\n  const fileNames = fs.readdirSync(postsDirectory);\n  return fileNames.map((fileName) => {\n    return {\n      params: {\n        slug: fileName.replace(/\\.md$/, \"\"),\n      },\n    };\n  });\n}\n\nexport async function getPostData(slug) {\n  const fullPath = path.join(postsDirectory, `${slug}.md`);\n  const fileContents = fs.readFileSync(fullPath, \"utf8\");\n\n  const matterResult = matter(fileContents);\n\n  const processedContent = await remark()\n    .use(html)\n    .process(matterResult.content);\n  const contentHtml = processedContent.toString();\n\n  return {\n    slug,\n    contentHtml,\n    ...matterResult.data,\n  };\n}\n\nexport function getCategories() {\n  const allPostData = getSortedPostsData();\n  const categories = [];\n  allPostData.forEach((post) => {\n    if (post.category && !categories.includes(post.category)) {\n      categories.push(post.category);\n    }\n  });\n  return categories;\n}\n\nexport function getCategoryPaths() {\n  const categories = getCategories();\n  return categories.map((category) => {\n    return {\n      params: {\n        category,\n      },\n    };\n  });\n}\n\nexport function getSortedCategoryPostsData(category) {\n  const allPostData = getSortedPostsData();\n  const categoryPostsData = [];\n  allPostData.forEach((post) => {\n    if (post.category === category) {\n      categoryPostsData.push(post);\n    }\n  });\n  return categoryPostsData;\n}\n\nexport function getTags() {\n  const allPostData = getSortedPostsData();\n  const tags = [];\n  allPostData.forEach((post) => {\n    if (post.tags) {\n      post.tags.forEach((tag) => {\n        if (!tags.includes(tag)) {\n          tags.push(tag);\n        }\n      });\n    }\n  });\n  return tags;\n}\n\nexport function getTagPaths() {\n  const tags = getTags();\n  return tags.map((tag) => {\n    return {\n      params: {\n        tag,\n      },\n    };\n  });\n}\n\nexport function getSortedTagPostsData(tag) {\n  const allPostData = getSortedPostsData();\n  const tagPostsData = [];\n  allPostData.forEach((post) => {\n    if (post.tags && post.tags.includes(tag)) {\n      tagPostsData.push(post);\n    }\n  });\n  return tagPostsData;\n}\n"]},"metadata":{},"sourceType":"module"}